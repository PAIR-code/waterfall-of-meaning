"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs-extra");
var path_1 = require("path");
var installations_1 = require("./installations");
var lockfile_1 = require("./lockfile");
var _1 = require(".");
var isYalcFileAddress = function (address, name) {
    var regExp = new RegExp('file|link:' + _1.values.yalcPackagesFolder + '/' + name);
    return regExp.test(address);
};
exports.removePackages = function (packages, options) {
    var workingDir = options.workingDir;
    var lockFileConfig = lockfile_1.readLockfile({ workingDir: workingDir });
    var pkg = _1.readPackageManifest(workingDir);
    if (!pkg)
        return;
    var packagesToRemove = [];
    if (packages.length) {
        packages.forEach(function (packageName) {
            var _a = _1.parsePackageName(packageName), name = _a.name, version = _a.version;
            if (lockFileConfig.packages[name]) {
                if (!version || version === lockFileConfig.packages[name].version) {
                    packagesToRemove.push(name);
                }
            }
            else {
                console.log("Package " + packageName + " not found in " + _1.values.lockfileName +
                    ", still will try to remove.");
                packagesToRemove.push(name);
            }
        });
    }
    else {
        if (options.all) {
            packagesToRemove = Object.keys(lockFileConfig.packages);
        }
        else {
            console.log("Use --all option to remove all packages.");
        }
    }
    var lockfileUpdated = false;
    var removedPackagedFromManifect = [];
    packagesToRemove.forEach(function (name) {
        var lockedPackage = lockFileConfig.packages[name];
        var depsWithPackage;
        if (pkg.dependencies && pkg.dependencies[name]) {
            depsWithPackage = pkg.dependencies;
        }
        if (pkg.devDependencies && pkg.devDependencies[name]) {
            depsWithPackage = pkg.devDependencies;
        }
        if (depsWithPackage &&
            isYalcFileAddress(depsWithPackage[name], name)) {
            removedPackagedFromManifect.push(name);
            if (lockedPackage && lockedPackage.replaced) {
                depsWithPackage[name] = lockedPackage.replaced;
            }
            else {
                delete depsWithPackage[name];
            }
        }
        if (!options.retreat) {
            lockfileUpdated = true;
            delete lockFileConfig.packages[name];
        }
    });
    if (lockfileUpdated) {
        lockfile_1.writeLockfile(lockFileConfig, { workingDir: workingDir });
    }
    if (!Object.keys(lockFileConfig.packages).length && !options.retreat) {
        fs.removeSync(path_1.join(workingDir, _1.values.yalcPackagesFolder));
        lockfile_1.removeLockfile({ workingDir: workingDir });
    }
    if (removedPackagedFromManifect.length) {
        _1.writePackageManifest(workingDir, pkg);
    }
    var installationsToRemove = packagesToRemove.map(function (name) { return ({
        name: name, version: '', path: workingDir
    }); });
    removedPackagedFromManifect.forEach(function (name) {
        fs.removeSync(path_1.join(workingDir, 'node_modules', name));
    });
    packagesToRemove.forEach(function (name) {
        if (!options.retreat) {
            fs.removeSync(path_1.join(workingDir, _1.values.yalcPackagesFolder, name));
        }
    });
    if (!options.retreat) {
        installations_1.removeInstallations(installationsToRemove);
    }
};
//# sourceMappingURL=remove.js.map