"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var child_process_1 = require("child_process");
var fs = require("fs-extra");
var path_1 = require("path");
var del = require("del");
var installations_1 = require("./installations");
var lockfile_1 = require("./lockfile");
var _1 = require(".");
var ensureSymlinkSync = fs.ensureSymlinkSync;
var getLatestPackageVersion = function (packageName) {
    var dir = _1.getPackageStoreDir(packageName);
    var versions = fs.readdirSync(dir);
    var latest = versions.map(function (version) { return ({
        version: version, created: fs.statSync(path_1.join(dir, version)).ctime.getTime()
    }); })
        .sort(function (a, b) { return b.created - a.created; }).map(function (x) { return x.version; })[0];
    return latest || '';
};
var emptyDirExcludeNodeModules = function (path) {
    // TODO: maybe use fs.remove + readdir for speed.
    del.sync('**', {
        dot: true,
        cwd: path,
        ignore: '**/node_modules/**'
    });
};
var isSymlink = function (path) {
    try {
        return !!fs.readlinkSync(path);
    }
    catch (e) {
        return false;
    }
};
exports.addPackages = function (packages, options) {
    var workingDir = options.workingDir;
    var localPkg = _1.readPackageManifest(workingDir);
    var localPkgUpdated = false;
    if (!localPkg) {
        return;
    }
    var addedInstalls = packages.map(function (packageName) {
        var _a = _1.parsePackageName(packageName), name = _a.name, _b = _a.version, version = _b === void 0 ? '' : _b;
        if (!name) {
            console.log('Could not parse package name', packageName);
        }
        var storedPackagePath = _1.getPackageStoreDir(name);
        if (!fs.existsSync(storedPackagePath)) {
            console.log("Could not find package `" + name + "` in store (" + storedPackagePath + "), skipping.");
            return null;
        }
        var versionToInstall = version || getLatestPackageVersion(name);
        var storedPackageDir = _1.getPackageStoreDir(name, versionToInstall);
        if (!fs.existsSync(storedPackageDir)) {
            console.log("Could not find package `" + packageName + "` " + storedPackageDir, ', skipping.');
            return null;
        }
        var pkg = _1.readPackageManifest(storedPackageDir);
        if (!pkg) {
            return;
        }
        var destYalcCopyDir = path_1.join(workingDir, _1.values.yalcPackagesFolder, name);
        var destModulesDir = path_1.join(workingDir, 'node_modules', name);
        emptyDirExcludeNodeModules(destYalcCopyDir);
        fs.copySync(storedPackageDir, destYalcCopyDir);
        var gracefulFs = require('graceful-fs');
        gracefulFs.gracefulify(fs);
        var replacedVersion = '';
        if (options.link || options.linkDep || isSymlink(destModulesDir)) {
            fs.removeSync(destModulesDir);
        }
        if (options.link || options.linkDep) {
            ensureSymlinkSync(destYalcCopyDir, destModulesDir, 'junction');
        }
        else {
            emptyDirExcludeNodeModules(destModulesDir);
            fs.copySync(destYalcCopyDir, destModulesDir);
        }
        if (!options.link) {
            var protocol = options.linkDep ? 'link:' : 'file:';
            var localAddress = protocol + _1.values.yalcPackagesFolder + '/' + pkg.name;
            var dependencies = localPkg.dependencies || {};
            var devDependencies = localPkg.devDependencies || {};
            var whereToAdd = options.dev
                ? devDependencies : dependencies;
            if (options.dev) {
                if (dependencies[pkg.name]) {
                    replacedVersion = dependencies[pkg.name];
                    delete dependencies[pkg.name];
                }
            }
            else {
                if (!dependencies[pkg.name]) {
                    if (devDependencies[pkg.name]) {
                        whereToAdd = devDependencies;
                    }
                }
            }
            if (whereToAdd[pkg.name] !== localAddress) {
                replacedVersion = replacedVersion || whereToAdd[pkg.name];
                whereToAdd[pkg.name] = localAddress;
                localPkg.dependencies = whereToAdd === dependencies
                    ? dependencies : localPkg.dependencies;
                localPkg.devDependencies = whereToAdd === devDependencies
                    ? devDependencies : localPkg.devDependencies;
                localPkgUpdated = true;
            }
            replacedVersion = replacedVersion == localAddress ? '' : replacedVersion;
        }
        var addedAction = options.link ? 'linked' : 'added';
        console.log(pkg.name + "@" + pkg.version + " " + addedAction + " ==> " + destModulesDir);
        var signature = _1.readSignatureFile(storedPackageDir);
        return {
            signature: signature,
            name: name,
            version: version,
            replaced: replacedVersion,
            path: options.workingDir
        };
    }).filter(function (_) { return _; });
    if (localPkgUpdated) {
        _1.writePackageManifest(workingDir, localPkg);
    }
    lockfile_1.addPackageToLockfile(addedInstalls
        .map(function (i) { return ({
        name: i.name,
        version: i.version,
        replaced: i.replaced,
        file: !options.link && !options.linkDep,
        link: options.linkDep,
        signature: i.signature
    }); }), { workingDir: options.workingDir });
    installations_1.addInstallations(addedInstalls);
    if (options.yarn) {
        var changeDirCmd = 'cd ' + options.workingDir + ' && ';
        child_process_1.execSync(changeDirCmd + 'yarn');
    }
};
//# sourceMappingURL=add.js.map