"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var ignore = require('ignore');
var fs = require("fs-extra");
var crypto = require("crypto");
var klaw = require("klaw");
var path_1 = require("path");
var _1 = require(".");
var shortSignatureLength = 8;
var npmIncludeDefaults = [
    'package.json'
];
var npmIgnoreDefaults = [
    '.*.swp',
    '._*',
    '.DS_Store',
    '.git',
    '.hg',
    '.npmrc',
    '.lock-wscript',
    '.svn',
    '.wafpickle-*',
    'config.gypi',
    'CVS',
    'npm-debug.log',
    'node_modules'
];
var npmFilesIncludedByDefault = [
    '/CHANGELOG',
    '/README',
    '/CHANGES',
    '/HISTORY',
    '/LICENSE',
    '/LICENCE',
    '/NOTICE',
    '/CHANGELOG.*',
    '/README.*',
    '/CHANGES.*',
    '/HISTORY.*',
    '/LICENSE.*',
    '/LICENCE.*',
    '/NOTICE.*'
];
var getFilesToCopy = function (workingDir, isIncluded) {
    var filter = function (filePath) {
        var f = path_1.relative(workingDir, filePath);
        if (!f)
            return true;
        var isDir = fs.statSync(filePath).isDirectory();
        return isIncluded(f, isDir);
    };
    return new Promise(function (resolve, reject) {
        var items = [];
        klaw(workingDir, { filter: filter })
            .on('data', function (item) {
            if (!item.stats.isDirectory()) {
                items.push(path_1.relative(workingDir, item.path));
            }
        }).on('end', function () {
            resolve(items);
        }).on('error', reject);
    });
};
var ensureDir = function (dirPath) { return new Promise(function (resolve, reject) {
    return fs.ensureDir(dirPath, function (err) { return err ? reject(err) : resolve(); });
}); };
var copyFile = function (srcPath, destPath, relPath) {
    return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
        var stream, md5sum;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, ensureDir(path_1.dirname(destPath))];
                case 1:
                    _a.sent();
                    stream = fs.createReadStream(srcPath);
                    md5sum = crypto.createHash("md5");
                    md5sum.update(relPath.replace(/\\/g, '/'));
                    stream.on('data', function (data) {
                        return md5sum.update(data);
                    });
                    stream
                        .pipe(fs.createWriteStream(destPath))
                        .on('error', reject)
                        .on('close', function () {
                        resolve(md5sum.digest('hex'));
                    });
                    return [2 /*return*/];
            }
        });
    }); });
};
var getIngoreFilesContent = function (workingDir, hasFilesEntry) {
    var content = '';
    var ignoreFiles = {
        npm: path_1.join(workingDir, '.npmignore'),
        yarn: path_1.join(workingDir, '.yarnignore'),
        git: path_1.join(workingDir, '.gitignore'),
    };
    if (fs.existsSync(ignoreFiles.npm)) {
        content += fs.readFileSync(ignoreFiles.npm, 'utf-8') + '\n';
    }
    if (fs.existsSync(ignoreFiles.yarn)) {
        content += fs.readFileSync(ignoreFiles.yarn, 'utf-8') + '\n';
    }
    if (!content.length && !hasFilesEntry && fs.existsSync(ignoreFiles.git)) {
        content += fs.readFileSync(ignoreFiles.git, 'utf-8');
    }
    return content;
};
var getFoldersPatterns = function (files) {
    return files.reduce(function (res, file) {
        return res.concat(file.split('/').filter(function (_) { return _; })
            .reduce(function (prev, folder) {
            return prev.concat([prev[prev.length - 1], folder].join('/'));
        }, []).map(function (x) { return x.slice(1); }));
    }, []);
};
exports.copyPackageToStore = function (pkg, options) { return __awaiter(_this, void 0, void 0, function () {
    var workingDir, ignoreRule, ignores, includeFoldersRule, explicitIncludeRule, includes, isIncluded, copyFromDir, locPackageStoreDir, filesToCopy, hashes, signature, shortSignature, ensureSymlinkSync_1, pkg_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                workingDir = options.workingDir;
                ignoreRule = ignore()
                    .add(npmIgnoreDefaults)
                    .add(npmFilesIncludedByDefault)
                    .add(getIngoreFilesContent(workingDir, !!pkg.files));
                ignores = function (f, isDir) {
                    return ignoreRule.ignores(f) || (isDir && ignoreRule.ignores(f + '/'));
                };
                includeFoldersRule = ignore().add(getFoldersPatterns(pkg.files || []));
                explicitIncludeRule = pkg.files ? ignore()
                    .add(npmIncludeDefaults)
                    .add(pkg.files || []) : null;
                includes = function (f, isDir) {
                    return explicitIncludeRule ?
                        explicitIncludeRule.ignores(f)
                            || (isDir && includeFoldersRule.ignores(f))
                        : true;
                };
                isIncluded = function (f, isDir) {
                    return !((ignores(f, isDir)) || !(includes(f, isDir)));
                };
                copyFromDir = options.workingDir;
                locPackageStoreDir = path_1.join(_1.getStorePackagesDir(), pkg.name, pkg.version);
                fs.removeSync(locPackageStoreDir);
                return [4 /*yield*/, getFilesToCopy(workingDir, isIncluded)];
            case 1:
                filesToCopy = _a.sent();
                return [4 /*yield*/, Promise.all(filesToCopy.sort().map(function (relPath) {
                        return copyFile(path_1.join(copyFromDir, relPath), path_1.join(locPackageStoreDir, relPath), relPath);
                    }))];
            case 2:
                hashes = _a.sent();
                signature = crypto.createHash('md5')
                    .update(hashes.join('')).digest('hex');
                shortSignature = signature.substr(0, shortSignatureLength);
                if (options.knit) {
                    fs.removeSync(locPackageStoreDir);
                    ensureSymlinkSync_1 = fs.ensureSymlinkSync;
                    filesToCopy.forEach(function (f) {
                        var source = path_1.join(copyFromDir, f);
                        if (fs.statSync(source).isDirectory()) {
                            return;
                        }
                        ensureSymlinkSync_1(source, path_1.join(locPackageStoreDir, f));
                    });
                }
                _1.writeSignatureFile(locPackageStoreDir, signature);
                if (options.signature && !options.knit) {
                    pkg_1 = _1.readPackageManifest(locPackageStoreDir);
                    if (pkg_1) {
                        pkg_1.version = [pkg_1.version, shortSignature].join('-');
                        _1.writePackageManifest(locPackageStoreDir, pkg_1);
                    }
                }
                return [2 /*return*/, signature];
        }
    });
}); };
//# sourceMappingURL=copy.js.map